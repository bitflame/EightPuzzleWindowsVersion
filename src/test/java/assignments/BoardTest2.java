package assignments;

import edu.princeton.cs.algs4.In;
import edu.princeton.cs.algs4.StdOut;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.io.EOFException;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@RunWith(Parameterized.class)
public class BoardTest2 {
    final static File neighborsTestsFolder = new
            File("C:\\Users\\Azizam\\IdeaProjects\\EightPuzzle\\src\\neighborstests");
    final static ArrayList<Object[]> filesList = new ArrayList<>();
    private static Object[] testInst;
    private static int expectedNeighborsCount = 0;
    private int[][] fInput;
    private boolean fExpected;
    final static String
            destFolder = "C:\\Users\\Azizam\\IdeaProjects\\EightPuzzle\\src\\neighborstests\\neigh_test_results";

    @Parameterized.Parameters(name = "{index}: Number of moves for [{0}]={2}")
    public static Iterable<Object[]> data() {
        List<int[][]> expectedNeighbors = new ArrayList<>();
        for (final File neighborFile : neighborsTestsFolder.listFiles()) {
            In in = new In(neighborFile.getAbsolutePath());
            String filename = neighborFile.getName();
            int n = in.readInt();
            while (!in.isEmpty()) {
                int[][] tiles = new int[n][n];
                for (int i = 0; i < n; i++)
                    for (int j = 0; j < n; j++)
                        tiles[i][j] = in.readInt();
                int[][] neigh1 = new int[n][n];
                expectedNeighborsCount++;
                for (int i = 0; i < n; i++)
                    for (int j = 0; j < n; j++)
                        neigh1[i][j] = in.readInt();
                expectedNeighbors.add(neigh1);
                expectedNeighborsCount++;
                int[][] neigh2 = new int[n][n];
                for (int i = 0; i < n; i++)
                    for (int j = 0; j < n; j++)
                        neigh2[i][j] = in.readInt();
                expectedNeighbors.add(neigh2);
                try {
                    if (in.isEmpty()) throw new EOFException();
                    expectedNeighborsCount++;
                    int[][] neigh3 = new int[n][n];
                    for (int i = 0; i < n; i++)
                        for (int j = 0; j < n; j++)
                            neigh3[i][j] = in.readInt();
                    expectedNeighbors.add(neigh3);
                } catch (EOFException e) {
                    StdOut.println("reached the end of the input file for neighbors test.");
                }
                try {
                    if (in.isEmpty()) throw new EOFException();
                    expectedNeighborsCount++;
                    int[][] neigh4 = new int[n][n];
                    for (int i = 0; i < n; i++)
                        for (int j = 0; j < n; j++)
                            tiles[i][j] = in.readInt();
                    expectedNeighbors.add(neigh4);
                } catch (EOFException e) {
                    StdOut.println("reached the end of the input file for neighbors test.");
                }
                testInst = new Object[]{filename, tiles, expectedNeighbors, expectedNeighborsCount};
                filesList.add(testInst);
            }
        }// added up to here for the neighbors test
        return filesList;
    }

    public BoardTest2(String filename, int[][] tiles, List<int[][]> neighbors, int expectedNeighborsCount) throws
            IOException {
        fInput = tiles;
        fExpected = true;
        Board a = new Board(fInput);
        // check to make sure all the expected neighbors are in the generated neighbors
        boolean neiExists = neighbors.stream().anyMatch(s -> s.equals(a.neighbors())); //
        boolean allNeigsExist = neighbors.stream().allMatch(s -> s.equals(a.neighbors())); //
        FileWriter myWriter = new FileWriter(destFolder + filename + "Here is the original board: " +
                "Here is the expected neighbors: " + neighbors + " Here are the neighbors generated by the program: " +
                a.neighbors());
        //fResult = a.equals(b);
        //myWriter.write("For " + filename + " the result is: " + fResult);
        myWriter.close();
        //File myObj = new File(destFolder, fileName);
        //fActual = board1.equals(board2);
    }

    @Test
    public void neighborsTest() throws IOException {
        // Board neighbors() method generates all the expected methods and the count matches with the expected count

    }
}
